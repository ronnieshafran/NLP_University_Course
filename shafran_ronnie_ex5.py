from sys import argv
from time import time, strftime, gmtime
from math import log

TAB = "    "
NEW_LINE = '\n'


class Rule:
    def __init__(self, source: '', target: [], probability: float):
        self.probability = probability
        self.target = target
        self.source = source



class TableEntry:
    def __init__(self, rule: Rule = None, coordinates: () = None, probability=0):
        self.max_rule = rule
        self.coordinates = coordinates
        self.max_probability = probability
        self.rules = []
        self.rules_probability = {}
        self.is_terminal = False
        self.text = None

    def __str__(self):
        return f"{self.max_rule.source} -> {self.max_rule.target} {self.max_rule.probability}"


class Grammar:
    def __init__(self):
        self.rules = []
        self.reverse_rules = {}

    def add_rules_from_file(self, file: ""):
        with open(file) as rules_file:
            for line in rules_file:
                words = [word.strip('\n').strip() for word in line.split(' ')]
                probability = float(words[0])
                source = words[1]
                target = words[3:]
                reversed_key = tuple(target)
                rule = Rule(source, reversed_key, probability)
                self.rules.append(rule)
                if self.reverse_rules.get(reversed_key) is None:
                    self.reverse_rules[reversed_key] = []
                self.reverse_rules[reversed_key].append(rule)

    def get_possible_rules(self, targets: ()):
        return self.reverse_rules.get(targets, [])


def cky(sentence: "", grammar: Grammar):
    words = [word.strip('\n').strip() for word in sentence.split(' ')]
    n = len(words)
    chart = [[TableEntry() for _ in range(n)] for _ in range(n)]
    for col in range(n):
        word = words[col]
        possible_rules = grammar.get_possible_rules((word, ))
        # init the main diagonal
        for rule in possible_rules:
            chart[col][col].max_probability = rule.probability
            chart[col][col].rules.append(rule)
            chart[col][col].rules_probability[rule] = rule.probability
            chart[col][col].is_terminal = True
            chart[col][col].text = word

        # main loop
        for row in range(col - 1, -1, -1):
            for k in range(row, col):
                for B in chart[row][k].rules:
                    for C in chart[k+1][col].rules:
                        for rule in grammar.get_possible_rules((B.source, C.source)):
                            p = rule.probability * chart[row][k].rules_probability[B] * chart[k+1][col].rules_probability[C]
                            chart[row][col].rules_probability[rule] = max(p, chart[row][col].rules_probability.get(rule, 0))
                            if p > chart[row][col].max_probability:
                                chart[row][col].max_rule = rule
                                chart[row][col].max_probability = p
                                chart[row][col].coordinates = ((row, k), (k+1, col))

    result_cell = chart[0][n - 1]
    if result_cell.max_probability == 0:
        return None, None
    else:
        return get_parsing_tree(chart, n), log(result_cell.max_probability)


def get_parsing_tree(chart, n):
    return "later"


if __name__ == '__main__':
    input_grammar = argv[1]  # The name of the file that contains the probabilistic grammar
    input_sentences = argv[2]  # The name of the file that contains the input sentences (tests)
    output_trees = argv[3]  # The name of the output file
    start_time = time()

    grammar = Grammar()
    print('Adding rules to grammar...')
    grammar.add_rules_from_file(input_grammar)
    print('Performing Probabilistic CKY Algorithm...')
    result = []
    with open(input_sentences) as file:
        for sentence in file:
            result.append(f'Sentence: {sentence}')
            parsing_tree, probability = cky(sentence, grammar)
            if parsing_tree is None:
                result.append("*** This sentence is not a member of the language generated by the grammar ***")
            else:
                result.append(f"Parsing:\n {parsing_tree}\n")
                result.append(f"Log Probability: {probability}\n\n")
    result_str = '\n'.join(result)
    print(result_str)
    # with open(output_trees, 'w', encoding='utf8') as output_file:
    #     output_file.write()
    print(f'Successfully written to file: {output_trees}')
    elapsed_time = time() - start_time
    print('================')
    print(f'Time Elapsed: {strftime("%H:%M:%S", gmtime(elapsed_time))}')
